# -*- coding: utf-8 -*-
"""
Author: Tygors Woo
Create on: 2019-04
"""


# 尝试通过散列构建一个搜索时间复杂度为O(1)的数据结构

# 散列表是一种元素集合，其中的元素以非常便于查找的方式存储

# 散列函数将散列表中的元素与其所属位置对应起来
# 散列表的占用率称为载荷因子，λ=元素个数/散列表大小，λ小则发生冲突的概率小
# 只有当每个元素的散列值不同时，散列表才有用，有时会出现冲突，也称碰撞


# 如果能将每个元素映射到不同的槽， 该散列函数称作【完美散列函数】

# 一个简单的散列函数：取余
# 取余函数的扩展
# 1.折叠法先将元素切成等长的部分（最后一部分的长度可能不同），然后将这些部分相加，得到散列值
# 2.隔数反转折叠法
# 3.平方取中法

def hash_str(a_str, table_size):
    # 异序词总会得到相同的散列值
    return sum([ord(c) for c in a_str]) % table_size

def hash_str_weighted(a_str, table_size):
    # 以字符出现位置作为权重
    return sum([ord(c) * (n+1) for n, c in enumerate(a_str)]) % table_size

# 处理冲突
# 1.简单的做法是从起初的散列值开始，顺序遍历散列表，直到找到一个空槽，开放定址，线性探测
# 2.线性探测有个缺点，就是会使散列表中的元素出现聚集现象，可以使用扩展线性探测，不再依次顺序查找空槽，而是跳过一些槽，例如+3
# 3.平方探测（h+i^2）%size
# 4.链接法，让槽指向元素集合


if __name__ == "__main__":
    print(hash_str_weighted("cat",11))